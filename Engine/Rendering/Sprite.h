////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2009 Alexander Poluektov
// All rights reserved
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// $Id: //depot/main/Engine/Rendering/Sprite.h#1 $
// $DateTime: 2009/08/05 15:00:45 $

// Sprite.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef ENGINE_RENDERING_SPRITE_H_INCLUDED
#define ENGINE_RENDERING_SPRITE_H_INCLUDED

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Engine/Rendering/Vertex.h"

#include <string>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Engine
{
namespace Rendering
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// Identifier of texture.
struct Texture_ID
{
   std::string file_name;
};

inline bool operator==(const Texture_ID& lhs, const Texture_ID& rhs) { return lhs.file_name == rhs.file_name; }
inline bool operator!=(const Texture_ID& lhs, const Texture_ID& rhs) { return !(lhs == rhs); }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// Sprite primary template.
/// Specializations typically hold graphical data that depend on Vertex_format.
template <Vertex_format>
struct Sprite;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// Colored (untextured) sprite.
template <>
struct Sprite<Vertex_format(position | diffuse_color)>
{
   Vertex<Vertex_format(position | diffuse_color)> vertexes[4];
};

typedef Sprite<Vertex_format(position | diffuse_color)> Colored_sprite;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// Sprite with one texture attached.
template <>
struct Sprite<Vertex_format(position | diffuse_color | texture_coord0)>
{
   Vertex<Vertex_format(position | diffuse_color | texture_coord0)> vertexes[4];
   Texture_ID     texture;
   /// Defines how texture should be blended with vertex-based diffuse colors.
   Blending_mode  blending;
};

typedef Sprite<Vertex_format(position | diffuse_color | texture_coord0)> Textured_sprite;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// Sprite with two textures attached.
template <>
struct Sprite<Vertex_format(position | diffuse_color | texture_coord0 | texture_coord1)>
{
   Vertex<Vertex_format(position | diffuse_color | texture_coord0 | texture_coord1)> vertexes[4];
   Texture_ID     texture0;
   /// Defines how texture should be blended with vertex-based diffuse colors.
   Blending_mode  blending0;
   /// Defines how texture should be blended with previous blending result.
   Texture_ID     texture1;
   Blending_mode  blending1;
};

typedef Sprite<Vertex_format(position | diffuse_color | texture_coord0 | texture_coord1)> Multitextured_2_sprite;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

} // namespace Rendering
} // namespace Engine

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif // ENGINE_RENDERING_SPRITE_H_INCLUDED

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
